(wx["webpackJsonp"] = wx["webpackJsonp"] || []).push([["vendors-node_modules_taro_weapp_prebundle_we-cropper_js"],{

/***/ "./node_modules/.taro/weapp/prebundle/we-cropper.core.js":
/*!***************************************************************!*\
  !*** ./node_modules/.taro/weapp/prebundle/we-cropper.core.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _chunk_P7VEE7PG_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-P7VEE7PG.js */ "./node_modules/.taro/weapp/prebundle/chunk-P7VEE7PG.js");
/* provided dependency */ var window = __webpack_require__(/*! ./node_modules/.taro/weapp/prebundle/chunk-6KSI5IDP.js */ "./node_modules/.taro/weapp/prebundle/chunk-6KSI5IDP.js")["window$1"];

// ../../node_modules/.pnpm/we-cropper@1.4.0/node_modules/we-cropper/dist/we-cropper.js
var require_we_cropper = (0,_chunk_P7VEE7PG_js__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({
    "../../node_modules/.pnpm/we-cropper@1.4.0/node_modules/we-cropper/dist/we-cropper.js" (exports, module) {
        (function(global2, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() :  false ? 0 : global2.WeCropper = factory();
        })(exports, function() {
            "use strict";
            var device = void 0;
            var TOUCH_STATE = [
                "touchstarted",
                "touchmoved",
                "touchended"
            ];
            var adaptAPI = {
                strokeStyle: "setStrokeStyle",
                fillStyle: "setFillStyle",
                lineWidth: "setLineWidth"
            };
            function firstLetterUpper(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }
            function setTouchState(instance) {
                var arg = [], len = arguments.length - 1;
                while(len-- > 0)arg[len] = arguments[len + 1];
                TOUCH_STATE.forEach(function(key, i) {
                    if (arg[i] !== void 0) {
                        instance[key] = arg[i];
                    }
                });
            }
            function validator(instance, o) {
                Object.defineProperties(instance, o);
            }
            function getDevice() {
                if (!device) {
                    device = wx.getSystemInfoSync();
                }
                return device;
            }
            function adapt2d(context, handle2, value) {
                if (context.type === "2d") {
                    context.ctx[handle2] = value;
                } else {
                    context.ctx[adaptAPI[handle2]](value);
                }
            }
            var tmp = {};
            var ref = getDevice();
            var pixelRatio = ref.pixelRatio;
            var DEFAULT = {
                id: {
                    default: "cropper",
                    get: function get() {
                        return tmp.id;
                    },
                    set: function set(value) {
                        if (typeof value !== "string") {
                            console.error("id\uFF1A" + value + " is invalid");
                        }
                        tmp.id = value;
                    }
                },
                width: {
                    default: 750,
                    get: function get() {
                        return tmp.width;
                    },
                    set: function set(value) {
                        if (typeof value !== "number") {
                            console.error("width\uFF1A" + value + " is invalid");
                        }
                        tmp.width = value;
                    }
                },
                height: {
                    default: 750,
                    get: function get() {
                        return tmp.height;
                    },
                    set: function set(value) {
                        if (typeof value !== "number") {
                            console.error("height\uFF1A" + value + " is invalid");
                        }
                        tmp.height = value;
                    }
                },
                pixelRatio: {
                    default: pixelRatio,
                    get: function get() {
                        return tmp.pixelRatio;
                    },
                    set: function set(value) {
                        if (typeof value !== "number") {
                            console.error("pixelRatio\uFF1A" + value + " is invalid");
                        }
                        tmp.pixelRatio = value;
                    }
                },
                scale: {
                    default: 2.5,
                    get: function get() {
                        return tmp.scale;
                    },
                    set: function set(value) {
                        if (typeof value !== "number") {
                            console.error("scale\uFF1A" + value + " is invalid");
                        }
                        tmp.scale = value;
                    }
                },
                zoom: {
                    default: 5,
                    get: function get() {
                        return tmp.zoom;
                    },
                    set: function set(value) {
                        if (typeof value !== "number") {
                            console.error("zoom\uFF1A" + value + " is invalid");
                        } else if (value < 0 || value > 10) {
                            console.error("zoom should be ranged in 0 ~ 10");
                        }
                        tmp.zoom = value;
                    }
                },
                src: {
                    default: "",
                    get: function get() {
                        return tmp.src;
                    },
                    set: function set(value) {
                        if (typeof value !== "string") {
                            console.error("src\uFF1A" + value + " is invalid");
                        }
                        tmp.src = value;
                    }
                },
                cut: {
                    default: {},
                    get: function get() {
                        return tmp.cut;
                    },
                    set: function set(value) {
                        if (typeof value !== "object") {
                            console.error("cut\uFF1A" + value + " is invalid");
                        }
                        tmp.cut = value;
                    }
                },
                boundStyle: {
                    default: {},
                    get: function get() {
                        return tmp.boundStyle;
                    },
                    set: function set(value) {
                        if (typeof value !== "object") {
                            console.error("boundStyle\uFF1A" + value + " is invalid");
                        }
                        tmp.boundStyle = value;
                    }
                },
                onReady: {
                    default: null,
                    get: function get() {
                        return tmp.ready;
                    },
                    set: function set(value) {
                        tmp.ready = value;
                    }
                },
                onBeforeImageLoad: {
                    default: null,
                    get: function get() {
                        return tmp.beforeImageLoad;
                    },
                    set: function set(value) {
                        tmp.beforeImageLoad = value;
                    }
                },
                onImageLoad: {
                    default: null,
                    get: function get() {
                        return tmp.imageLoad;
                    },
                    set: function set(value) {
                        tmp.imageLoad = value;
                    }
                },
                onBeforeDraw: {
                    default: null,
                    get: function get() {
                        return tmp.beforeDraw;
                    },
                    set: function set(value) {
                        tmp.beforeDraw = value;
                    }
                }
            };
            var ref$1 = getDevice();
            var windowWidth = ref$1.windowWidth;
            function prepare() {
                var self2 = this;
                self2.attachPage = function() {
                    var pages = getCurrentPages();
                    var pageContext = pages[pages.length - 1];
                    Object.defineProperty(pageContext, "wecropper", {
                        get: function get() {
                            console.warn("Instance will not be automatically bound to the page after v1.4.0\n\nPlease use a custom instance name instead\n\nExample: \nthis.mycropper = new WeCropper(options)\n\n// ...\nthis.mycropper.getCropperImage()");
                            return self2;
                        },
                        configurable: true
                    });
                };
                self2.createCtx = function() {
                    var id = self2.id;
                    var targetId = self2.targetId;
                    if (id) {
                        self2.ctx = self2.ctx || wx.createCanvasContext(id);
                        self2.targetCtx = self2.targetCtx || wx.createCanvasContext(targetId);
                        if (typeof self2.ctx.setStrokeStyle !== "function") {
                            self2.type = "2d";
                        }
                    } else {
                        console.error("constructor: create canvas context failed, 'id' must be valuable");
                    }
                };
                self2.deviceRadio = windowWidth / 750;
            }
            var isFunc = function(v) {
                return typeof v === "function";
            };
            var EVENT_TYPE = [
                "ready",
                "beforeImageLoad",
                "beforeDraw",
                "imageLoad"
            ];
            function observer() {
                var self2 = this;
                self2.on = function(event, fn) {
                    if (EVENT_TYPE.indexOf(event) > -1) {
                        if (isFunc(fn)) {
                            event === "ready" ? fn(self2) : self2["on" + firstLetterUpper(event)] = fn;
                        }
                    } else {
                        console.error("event: " + event + " is invalid");
                    }
                    return self2;
                };
            }
            function wxPromise(fn) {
                return function(obj) {
                    var args = [], len = arguments.length - 1;
                    while(len-- > 0)args[len] = arguments[len + 1];
                    if (obj === void 0) obj = {};
                    return new Promise(function(resolve, reject) {
                        obj.success = function(res) {
                            resolve(res);
                        };
                        obj.fail = function(err) {
                            reject(err);
                        };
                        fn.apply(void 0, [
                            obj
                        ].concat(args));
                    });
                };
            }
            function draw(ctx, reserve) {
                if (reserve === void 0) reserve = false;
                return new Promise(function(resolve) {
                    ctx.draw && ctx.draw(reserve, resolve);
                });
            }
            var getImageInfo = wxPromise(wx.getImageInfo);
            var canvasToTempFilePath = wxPromise(wx.canvasToTempFilePath);
            var loadCanvasImage = function(context, src) {
                return new Promise(function(resolve, reject) {
                    if (context.type === "2d") {
                        var img = context.canvas.createImage();
                        img.onload = function() {
                            resolve(img);
                        };
                        img.onerror = function(e) {
                            reject(e);
                        };
                        img.src = src;
                    } else {
                        resolve(src);
                    }
                });
            };
            var commonjsGlobal = typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
            function createCommonjsModule(fn, module2) {
                return module2 = {
                    exports: {}
                }, fn(module2, module2.exports), module2.exports;
            }
            var base64 = createCommonjsModule(function(module2, exports2) {
                (function(root) {
                    var freeExports = exports2;
                    var freeModule = module2 && module2.exports == freeExports && module2;
                    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                        root = freeGlobal;
                    }
                    var InvalidCharacterError = function(message) {
                        this.message = message;
                    };
                    InvalidCharacterError.prototype = new Error();
                    InvalidCharacterError.prototype.name = "InvalidCharacterError";
                    var error = function(message) {
                        throw new InvalidCharacterError(message);
                    };
                    var TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
                    var decode = function(input) {
                        input = String(input).replace(REGEX_SPACE_CHARACTERS, "");
                        var length = input.length;
                        if (length % 4 == 0) {
                            input = input.replace(/==?$/, "");
                            length = input.length;
                        }
                        if (length % 4 == 1 || /[^+a-zA-Z0-9/]/.test(input)) {
                            error("Invalid character: the string to be decoded is not correctly encoded.");
                        }
                        var bitCounter = 0;
                        var bitStorage;
                        var buffer;
                        var output = "";
                        var position = -1;
                        while(++position < length){
                            buffer = TABLE.indexOf(input.charAt(position));
                            bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
                            if (bitCounter++ % 4) {
                                output += String.fromCharCode(255 & bitStorage >> (-2 * bitCounter & 6));
                            }
                        }
                        return output;
                    };
                    var encode = function(input) {
                        input = String(input);
                        if (/[^\0-\xFF]/.test(input)) {
                            error("The string to be encoded contains characters outside of the Latin1 range.");
                        }
                        var padding = input.length % 3;
                        var output = "";
                        var position = -1;
                        var a;
                        var b;
                        var c;
                        var buffer;
                        var length = input.length - padding;
                        while(++position < length){
                            a = input.charCodeAt(position) << 16;
                            b = input.charCodeAt(++position) << 8;
                            c = input.charCodeAt(++position);
                            buffer = a + b + c;
                            output += TABLE.charAt(buffer >> 18 & 63) + TABLE.charAt(buffer >> 12 & 63) + TABLE.charAt(buffer >> 6 & 63) + TABLE.charAt(buffer & 63);
                        }
                        if (padding == 2) {
                            a = input.charCodeAt(position) << 8;
                            b = input.charCodeAt(++position);
                            buffer = a + b;
                            output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 63) + TABLE.charAt(buffer << 2 & 63) + "=";
                        } else if (padding == 1) {
                            buffer = input.charCodeAt(position);
                            output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 63) + "==";
                        }
                        return output;
                    };
                    var base642 = {
                        "encode": encode,
                        "decode": decode,
                        "version": "0.1.0"
                    };
                    if (false) {} else if (freeExports && !freeExports.nodeType) {
                        if (freeModule) {
                            freeModule.exports = base642;
                        } else {
                            for(var key in base642){
                                base642.hasOwnProperty(key) && (freeExports[key] = base642[key]);
                            }
                        }
                    } else {
                        root.base64 = base642;
                    }
                })(commonjsGlobal);
            });
            function makeURI(strData, type) {
                return "data:" + type + ";base64," + strData;
            }
            function fixType(type) {
                type = type.toLowerCase().replace(/jpg/i, "jpeg");
                var r = type.match(/png|jpeg|bmp|gif/)[0];
                return "image/" + r;
            }
            function encodeData(data) {
                var str = "";
                if (typeof data === "string") {
                    str = data;
                } else {
                    for(var i = 0; i < data.length; i++){
                        str += String.fromCharCode(data[i]);
                    }
                }
                return base64.encode(str);
            }
            function getImageData(canvasId, x, y, width, height, done) {
                wx.canvasGetImageData({
                    canvasId,
                    x,
                    y,
                    width,
                    height,
                    success: function success(res) {
                        done(res, null);
                    },
                    fail: function fail(res) {
                        done(null, res);
                    }
                });
            }
            function genBitmapImage(oData) {
                var biWidth = oData.width;
                var biHeight = oData.height;
                var biSizeImage = biWidth * biHeight * 3;
                var bfSize = biSizeImage + 54;
                var BITMAPFILEHEADER = [
                    66,
                    77,
                    bfSize & 255,
                    bfSize >> 8 & 255,
                    bfSize >> 16 & 255,
                    bfSize >> 24 & 255,
                    0,
                    0,
                    0,
                    0,
                    54,
                    0,
                    0,
                    0
                ];
                var BITMAPINFOHEADER = [
                    40,
                    0,
                    0,
                    0,
                    biWidth & 255,
                    biWidth >> 8 & 255,
                    biWidth >> 16 & 255,
                    biWidth >> 24 & 255,
                    biHeight & 255,
                    biHeight >> 8 & 255,
                    biHeight >> 16 & 255,
                    biHeight >> 24 & 255,
                    1,
                    0,
                    24,
                    0,
                    0,
                    0,
                    0,
                    0,
                    biSizeImage & 255,
                    biSizeImage >> 8 & 255,
                    biSizeImage >> 16 & 255,
                    biSizeImage >> 24 & 255,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ];
                var iPadding = (4 - biWidth * 3 % 4) % 4;
                var aImgData = oData.data;
                var strPixelData = "";
                var biWidth4 = biWidth << 2;
                var y = biHeight;
                var fromCharCode = String.fromCharCode;
                do {
                    var iOffsetY = biWidth4 * (y - 1);
                    var strPixelRow = "";
                    for(var x = 0; x < biWidth; x++){
                        var iOffsetX = x << 2;
                        strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) + fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) + fromCharCode(aImgData[iOffsetY + iOffsetX]);
                    }
                    for(var c = 0; c < iPadding; c++){
                        strPixelRow += String.fromCharCode(0);
                    }
                    strPixelData += strPixelRow;
                }while (--y)
                var strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData);
                return strEncoded;
            }
            function convertToImage(canvasId, x, y, width, height, type, done) {
                if (done === void 0) done = function() {};
                if (type === void 0) {
                    type = "png";
                }
                type = fixType(type);
                if (/bmp/.test(type)) {
                    getImageData(canvasId, x, y, width, height, function(data, err) {
                        var strData = genBitmapImage(data);
                        isFunc(done) && done(makeURI(strData, "image/" + type), err);
                    });
                } else {
                    console.error("\u6682\u4E0D\u652F\u6301\u751F\u6210'" + type + "'\u7C7B\u578B\u7684base64\u56FE\u7247");
                }
            }
            var CanvasToBase64 = {
                convertToImage,
                convertToBMP: function(ref2, done) {
                    if (ref2 === void 0) ref2 = {};
                    var canvasId = ref2.canvasId;
                    var x = ref2.x;
                    var y = ref2.y;
                    var width = ref2.width;
                    var height = ref2.height;
                    if (done === void 0) done = function() {};
                    return convertToImage(canvasId, x, y, width, height, "bmp", done);
                }
            };
            function methods() {
                var self2 = this;
                var boundWidth = self2.width;
                var boundHeight = self2.height;
                var id = self2.id;
                var targetId = self2.targetId;
                var pixelRatio2 = self2.pixelRatio;
                var ref2 = self2.cut;
                var x = ref2.x;
                if (x === void 0) x = 0;
                var y = ref2.y;
                if (y === void 0) y = 0;
                var width = ref2.width;
                if (width === void 0) width = boundWidth;
                var height = ref2.height;
                if (height === void 0) height = boundHeight;
                self2.updateCanvas = function(done) {
                    if (self2.croperTarget) {
                        self2.ctx.drawImage(self2.croperTarget, self2.imgLeft, self2.imgTop, self2.scaleWidth, self2.scaleHeight);
                    }
                    isFunc(self2.onBeforeDraw) && self2.onBeforeDraw(self2.ctx, self2);
                    self2.setBoundStyle(self2.boundStyle);
                    if (self2.type !== "2d") {
                        self2.ctx.draw(false, done);
                    }
                    done && done();
                    return self2;
                };
                self2.pushOrigin = self2.pushOrign = function(src) {
                    self2.src = src;
                    isFunc(self2.onBeforeImageLoad) && self2.onBeforeImageLoad(self2.ctx, self2);
                    return loadCanvasImage(self2, src).then(function(img) {
                        self2.croperTarget = img;
                        return getImageInfo({
                            src
                        }).then(function(res) {
                            var innerAspectRadio = res.width / res.height;
                            var customAspectRadio = width / height;
                            if (innerAspectRadio < customAspectRadio) {
                                self2.rectX = x;
                                self2.baseWidth = width;
                                self2.baseHeight = width / innerAspectRadio;
                                self2.rectY = y - Math.abs((height - self2.baseHeight) / 2);
                            } else {
                                self2.rectY = y;
                                self2.baseWidth = height * innerAspectRadio;
                                self2.baseHeight = height;
                                self2.rectX = x - Math.abs((width - self2.baseWidth) / 2);
                            }
                            self2.imgLeft = self2.rectX;
                            self2.imgTop = self2.rectY;
                            self2.scaleWidth = self2.baseWidth;
                            self2.scaleHeight = self2.baseHeight;
                            self2.update();
                            return new Promise(function(resolve) {
                                self2.updateCanvas(resolve);
                            });
                        }).then(function() {
                            isFunc(self2.onImageLoad) && self2.onImageLoad(self2.ctx, self2);
                        });
                    });
                };
                self2.removeImage = function() {
                    self2.src = "";
                    self2.croperTarget = "";
                    if (self2.type === "2d") {
                        return self2.ctx.clearRect(0, 0, self2.canvas.width, self2.canvas.height);
                    } else {
                        return draw(self2.ctx);
                    }
                };
                self2.getCropperBase64 = function(done) {
                    if (done === void 0) done = function() {};
                    CanvasToBase64.convertToBMP({
                        canvasId: id,
                        x,
                        y,
                        width,
                        height
                    }, done);
                };
                self2.getCropperImage = function(opt, fn) {
                    var customOptions = Object.assign({
                        fileType: "jpg"
                    }, opt);
                    var callback = isFunc(opt) ? opt : isFunc(fn) ? fn : null;
                    var canvasOptions = {
                        canvasId: id,
                        x,
                        y,
                        width,
                        height
                    };
                    if (self2.type === "2d") {
                        canvasOptions.canvas = self2.canvas;
                    }
                    var task = function() {
                        return Promise.resolve();
                    };
                    if (customOptions.original) {
                        task = function() {
                            self2.targetCtx.drawImage(self2.croperTarget, self2.imgLeft * pixelRatio2, self2.imgTop * pixelRatio2, self2.scaleWidth * pixelRatio2, self2.scaleHeight * pixelRatio2);
                            canvasOptions = {
                                canvasId: targetId,
                                x: x * pixelRatio2,
                                y: y * pixelRatio2,
                                width: width * pixelRatio2,
                                height: height * pixelRatio2
                            };
                            return draw(self2.targetCtx);
                        };
                    }
                    return task().then(function() {
                        Object.assign(canvasOptions, customOptions);
                        var arg = canvasOptions.componentContext ? [
                            canvasOptions,
                            canvasOptions.componentContext
                        ] : [
                            canvasOptions
                        ];
                        return canvasToTempFilePath.apply(null, arg);
                    }).then(function(res) {
                        var tempFilePath = res.tempFilePath;
                        return callback ? callback.call(self2, tempFilePath, null) : tempFilePath;
                    }).catch(function(err) {
                        if (callback) {
                            callback.call(self2, null, err);
                        } else {
                            throw err;
                        }
                    });
                };
            }
            var getNewScale = function(oldScale, oldDistance, zoom, touch0, touch1) {
                var xMove, yMove, newDistance;
                xMove = Math.round(touch1.x - touch0.x);
                yMove = Math.round(touch1.y - touch0.y);
                newDistance = Math.round(Math.sqrt(xMove * xMove + yMove * yMove));
                return oldScale + 1e-3 * zoom * (newDistance - oldDistance);
            };
            function update() {
                var self2 = this;
                if (!self2.src) {
                    return;
                }
                self2.__oneTouchStart = function(touch) {
                    self2.touchX0 = Math.round(touch.x);
                    self2.touchY0 = Math.round(touch.y);
                };
                self2.__oneTouchMove = function(touch) {
                    var xMove, yMove;
                    if (self2.touchended) {
                        return self2.updateCanvas();
                    }
                    xMove = Math.round(touch.x - self2.touchX0);
                    yMove = Math.round(touch.y - self2.touchY0);
                    var imgLeft = Math.round(self2.rectX + xMove);
                    var imgTop = Math.round(self2.rectY + yMove);
                    self2.outsideBound(imgLeft, imgTop);
                    self2.updateCanvas();
                };
                self2.__twoTouchStart = function(touch0, touch1) {
                    var xMove, yMove, oldDistance;
                    self2.touchX1 = Math.round(self2.rectX + self2.scaleWidth / 2);
                    self2.touchY1 = Math.round(self2.rectY + self2.scaleHeight / 2);
                    xMove = Math.round(touch1.x - touch0.x);
                    yMove = Math.round(touch1.y - touch0.y);
                    oldDistance = Math.round(Math.sqrt(xMove * xMove + yMove * yMove));
                    self2.oldDistance = oldDistance;
                };
                self2.__twoTouchMove = function(touch0, touch1) {
                    var oldScale = self2.oldScale;
                    var oldDistance = self2.oldDistance;
                    var scale = self2.scale;
                    var zoom = self2.zoom;
                    self2.newScale = getNewScale(oldScale, oldDistance, zoom, touch0, touch1);
                    self2.newScale <= 1 && (self2.newScale = 1);
                    self2.newScale >= scale && (self2.newScale = scale);
                    self2.scaleWidth = Math.round(self2.newScale * self2.baseWidth);
                    self2.scaleHeight = Math.round(self2.newScale * self2.baseHeight);
                    var imgLeft = Math.round(self2.touchX1 - self2.scaleWidth / 2);
                    var imgTop = Math.round(self2.touchY1 - self2.scaleHeight / 2);
                    self2.outsideBound(imgLeft, imgTop);
                    self2.updateCanvas();
                };
                self2.__xtouchEnd = function() {
                    self2.oldScale = self2.newScale;
                    self2.rectX = self2.imgLeft;
                    self2.rectY = self2.imgTop;
                };
            }
            var handle = {
                touchStart: function touchStart(e) {
                    var self2 = this;
                    var ref2 = e.touches;
                    var touch0 = ref2[0];
                    var touch1 = ref2[1];
                    if (!self2.src) {
                        return;
                    }
                    setTouchState(self2, true, null, null);
                    self2.__oneTouchStart(touch0);
                    if (e.touches.length >= 2) {
                        self2.__twoTouchStart(touch0, touch1);
                    }
                },
                touchMove: function touchMove(e) {
                    var self2 = this;
                    var ref2 = e.touches;
                    var touch0 = ref2[0];
                    var touch1 = ref2[1];
                    if (!self2.src) {
                        return;
                    }
                    setTouchState(self2, null, true);
                    if (e.touches.length === 1) {
                        self2.__oneTouchMove(touch0);
                    }
                    if (e.touches.length >= 2) {
                        self2.__twoTouchMove(touch0, touch1);
                    }
                },
                touchEnd: function touchEnd(e) {
                    var self2 = this;
                    if (!self2.src) {
                        return;
                    }
                    setTouchState(self2, false, false, true);
                    self2.__xtouchEnd();
                }
            };
            function cut() {
                var self2 = this;
                var boundWidth = self2.width;
                var boundHeight = self2.height;
                var ref2 = self2.cut;
                var x = ref2.x;
                if (x === void 0) x = 0;
                var y = ref2.y;
                if (y === void 0) y = 0;
                var width = ref2.width;
                if (width === void 0) width = boundWidth;
                var height = ref2.height;
                if (height === void 0) height = boundHeight;
                self2.outsideBound = function(imgLeft, imgTop) {
                    self2.imgLeft = imgLeft >= x ? x : self2.scaleWidth + imgLeft - x <= width ? x + width - self2.scaleWidth : imgLeft;
                    self2.imgTop = imgTop >= y ? y : self2.scaleHeight + imgTop - y <= height ? y + height - self2.scaleHeight : imgTop;
                };
                self2.setBoundStyle = function(ref3) {
                    if (ref3 === void 0) ref3 = {};
                    var color = ref3.color;
                    if (color === void 0) color = "#04b00f";
                    var mask = ref3.mask;
                    if (mask === void 0) mask = "rgba(0, 0, 0, 0.3)";
                    var lineWidth = ref3.lineWidth;
                    if (lineWidth === void 0) lineWidth = 1;
                    var half = lineWidth / 2;
                    var boundOption = [
                        {
                            start: {
                                x: x - half,
                                y: y + 10 - half
                            },
                            step1: {
                                x: x - half,
                                y: y - half
                            },
                            step2: {
                                x: x + 10 - half,
                                y: y - half
                            }
                        },
                        {
                            start: {
                                x: x - half,
                                y: y + height - 10 + half
                            },
                            step1: {
                                x: x - half,
                                y: y + height + half
                            },
                            step2: {
                                x: x + 10 - half,
                                y: y + height + half
                            }
                        },
                        {
                            start: {
                                x: x + width - 10 + half,
                                y: y - half
                            },
                            step1: {
                                x: x + width + half,
                                y: y - half
                            },
                            step2: {
                                x: x + width + half,
                                y: y + 10 - half
                            }
                        },
                        {
                            start: {
                                x: x + width + half,
                                y: y + height - 10 + half
                            },
                            step1: {
                                x: x + width + half,
                                y: y + height + half
                            },
                            step2: {
                                x: x + width - 10 + half,
                                y: y + height + half
                            }
                        }
                    ];
                    self2.ctx.beginPath();
                    adapt2d(self2, "fillStyle", mask);
                    self2.ctx.fillRect(0, 0, x, boundHeight);
                    self2.ctx.fillRect(x, 0, width, y);
                    self2.ctx.fillRect(x, y + height, width, boundHeight - y - height);
                    self2.ctx.fillRect(x + width, 0, boundWidth - x - width, boundHeight);
                    self2.ctx.fill();
                    boundOption.forEach(function(op) {
                        self2.ctx.beginPath();
                        adapt2d(self2, "strokeStyle", color);
                        adapt2d(self2, "lineWidth", lineWidth);
                        self2.ctx.moveTo(op.start.x, op.start.y);
                        self2.ctx.lineTo(op.step1.x, op.step1.y);
                        self2.ctx.lineTo(op.step2.x, op.step2.y);
                        self2.ctx.stroke();
                    });
                };
            }
            var version = "1.4.0";
            var WeCropper = function WeCropper2(params) {
                var self2 = this;
                var _default = {};
                validator(self2, DEFAULT);
                Object.keys(DEFAULT).forEach(function(key) {
                    _default[key] = DEFAULT[key].default;
                });
                Object.assign(self2, _default, params);
                self2.prepare();
                self2.attachPage();
                self2.createCtx();
                self2.observer();
                self2.cutt();
                self2.methods();
                self2.init();
                self2.update();
                return self2;
            };
            WeCropper.prototype.init = function init() {
                var self2 = this;
                var src = self2.src;
                self2.version = version;
                typeof self2.onReady === "function" && self2.onReady(self2.ctx, self2);
                if (src) {
                    self2.pushOrign(src);
                } else {
                    self2.updateCanvas();
                }
                setTouchState(self2, false, false, false);
                self2.oldScale = 1;
                self2.newScale = 1;
                return self2;
            };
            Object.assign(WeCropper.prototype, handle);
            WeCropper.prototype.prepare = prepare;
            WeCropper.prototype.observer = observer;
            WeCropper.prototype.methods = methods;
            WeCropper.prototype.cutt = cut;
            WeCropper.prototype.update = update;
            return WeCropper;
        });
    }
});
// entry:we-cropper
var require_we_cropper2 = (0,_chunk_P7VEE7PG_js__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({
    "entry:we-cropper" (exports, module) {
        module.exports = require_we_cropper();
    }
});
/* harmony default export */ __webpack_exports__["default"] = (require_we_cropper2()); /*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */  /**
 * we-cropper v1.4.0
 * (c) 2021 dlhandsome
 * @license MIT
 */ 


/***/ }),

/***/ "./node_modules/.taro/weapp/prebundle/we-cropper.js":
/*!**********************************************************!*\
  !*** ./node_modules/.taro/weapp/prebundle/we-cropper.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var m = __webpack_require__(/*! ./we-cropper.core.js */ "./node_modules/.taro/weapp/prebundle/we-cropper.core.js");
                   module.exports = m.default;
                   exports["default"] = module.exports;
                  

/***/ })

}]);